
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Chapter 3: Stochastic Simulations in pymc2 &#8212; GemPy rc documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     'rc',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Chapter 4: Bayesian Statistics in pymc3 (Working in progress proof of concept)" href="ch4.html" />
    <link rel="prev" title="Chapter 2: A real example. Importing data and setting series" href="ch2.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/./logos/gempy.png" alt="Logo"/>
    
    <h1 class="logo logo-name">GemPy</h1>
    
  </a>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=cgre-aachen&repo=gempy&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





    

<p>
<a href="https://travis-ci.org/cgre-aachen/gempy">
    <img
        alt="https://secure.travis-ci.org/cgre-aachen/gempy.svg?branch=master"
        src="https://secure.travis-ci.org/cgre-aachen/gempy.svg?branch=master"
    />
</a>
</p>


<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">GemPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_theory/motivation.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../tutorial.html">Tutorial</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="ch1.html">Chapter 1: Basics of geological modeling with GemPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch2.html">Chapter 2: A real example. Importing data and setting series</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Chapter 3: Stochastic Simulations in pymc2</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#preparation">Preparation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initialize-an-example-model">Initialize an example model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#visualize-the-input-data">Visualize the input data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compile-the-interpolator-function">Compile the interpolator function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#setting-up-the-pymc-functions">Setting up the pymc-Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#setting-up-the-parameter-distributions">Setting up the parameter distributions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#input-data-handling">Input data handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modeling-function">Modeling function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#analyzing-the-results">Analyzing the results</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ch4.html">Chapter 4: Bayesian Statistics in pymc3 (Working in progress proof of concept)</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch5.html">Chapter 5: Computing forward gravity. (Under development)</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch6.html">Chapter 6: Analyzing Topology (WIP)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../theory.html">Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code.html">Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../about.html">About us</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="../tutorial.html">Tutorial</a><ul>
      <li>Previous: <a href="ch2.html" title="previous chapter">Chapter 2: A real example. Importing data and setting series</a></li>
      <li>Next: <a href="ch4.html" title="next chapter">Chapter 4: Bayesian Statistics in pymc3 (Working in progress proof of concept)</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="chapter-3-stochastic-simulations-in-pymc2">
<h1>Chapter 3: Stochastic Simulations in pymc2<a class="headerlink" href="#chapter-3-stochastic-simulations-in-pymc2" title="Permalink to this headline">¶</a></h1>
<p>This tutorial will show you how to use GemPy for stochastic simulation
of geological models. We will address two approaches for this: (i) Monte
Carlo forward simulation, treating input data as uncertain parameter
distributions; (ii) Bayesian inference, where we extent the approach
with the use of likelihood functions to constrain the stochastic
modeling results with additional data.</p>
<div class="section" id="preparation">
<h2>Preparation<a class="headerlink" href="#preparation" title="Permalink to this headline">¶</a></h2>
<p>Import GemPy, matplotlib for plotting, numpy and pandas for data
handling.</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;../..&quot;</span><span class="p">)</span>

<span class="c1"># import gempy</span>
<span class="kn">import</span> <span class="nn">gempy</span> <span class="kn">as</span> <span class="nn">gp</span>

<span class="c1"># inline figures in jupyter notebooks</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="o">%</span><span class="k">matplotlib</span> inline

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pn</span>
<span class="kn">import</span> <span class="nn">theano</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">WARNING</span> <span class="p">(</span><span class="n">theano</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">blas</span><span class="p">):</span> <span class="n">Using</span> <span class="n">NumPy</span> <span class="n">C</span><span class="o">-</span><span class="n">API</span> <span class="n">based</span> <span class="n">implementation</span> <span class="k">for</span> <span class="n">BLAS</span> <span class="n">functions</span><span class="o">.</span>
</pre></div>
</div>
</div>
<div class="section" id="initialize-an-example-model">
<h2>Initialize an example model<a class="headerlink" href="#initialize-an-example-model" title="Permalink to this headline">¶</a></h2>
<p>First we define the cube size and model extent of our model and
initialize the GemPy data object:</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="c1"># set cube size and model extent</span>
<span class="n">cs</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">extent</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3000</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>  <span class="c1"># (x, y, z)</span>
<span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="mi">120</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="c1"># initialize geo_data object</span>
<span class="n">geo_data</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">create_data</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                           <span class="mi">0</span><span class="p">,</span> <span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                           <span class="mi">0</span><span class="p">,</span> <span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
                          <span class="n">resolution</span><span class="o">=</span><span class="p">[</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>  <span class="c1"># number of voxels</span>
                                      <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                      <span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
</pre></div>
</div>
<p>Then we use pandas to load the example data stored as csv files:</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">geo_data</span><span class="o">.</span><span class="n">set_interfaces</span><span class="p">(</span><span class="n">pn</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;../input_data/tutorial_ch3_interfaces&quot;</span><span class="p">,</span>
                                    <span class="n">index_col</span><span class="o">=</span><span class="s2">&quot;Unnamed: 0&quot;</span><span class="p">))</span>
<span class="n">geo_data</span><span class="o">.</span><span class="n">set_orientations</span><span class="p">(</span><span class="n">pn</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;../input_data/tutorial_ch3_foliations&quot;</span><span class="p">,</span>
                                    <span class="n">index_col</span><span class="o">=</span><span class="s2">&quot;Unnamed: 0&quot;</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="c1"># let&#39;s have a look at the upper five interface data entries in the dataframe</span>
<span class="n">gp</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">geo_data</span><span class="p">,</span> <span class="s1">&#39;interfaces&#39;</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>X</th>
      <th>X_std</th>
      <th>Y</th>
      <th>Y_std</th>
      <th>Z</th>
      <th>Z_std</th>
      <th>annotations</th>
      <th>formation</th>
      <th>formation_number</th>
      <th>group_id</th>
      <th>isFault</th>
      <th>order_series</th>
      <th>series</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>250</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>996</td>
      <td>0</td>
      <td>${\bf{x}}_{\alpha \,{\bf{1}},0}$</td>
      <td>Layer 2</td>
      <td>1</td>
      <td>l2_a</td>
      <td>False</td>
      <td>1</td>
      <td>Default serie</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2500</td>
      <td>0</td>
      <td>200</td>
      <td>0</td>
      <td>1149</td>
      <td>0</td>
      <td>${\bf{x}}_{\alpha \,{\bf{1}},1}$</td>
      <td>Layer 2</td>
      <td>1</td>
      <td>l2_b</td>
      <td>False</td>
      <td>1</td>
      <td>Default serie</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2250</td>
      <td>0</td>
      <td>100</td>
      <td>0</td>
      <td>1298</td>
      <td>0</td>
      <td>${\bf{x}}_{\alpha \,{\bf{1}},2}$</td>
      <td>Layer 2</td>
      <td>1</td>
      <td>l2_b</td>
      <td>False</td>
      <td>1</td>
      <td>Default serie</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2750</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>995</td>
      <td>0</td>
      <td>${\bf{x}}_{\alpha \,{\bf{1}},3}$</td>
      <td>Layer 2</td>
      <td>1</td>
      <td>l2_b</td>
      <td>False</td>
      <td>1</td>
      <td>Default serie</td>
    </tr>
    <tr>
      <th>4</th>
      <td>500</td>
      <td>0</td>
      <td>200</td>
      <td>0</td>
      <td>1149</td>
      <td>0</td>
      <td>${\bf{x}}_{\alpha \,{\bf{1}},4}$</td>
      <td>Layer 2</td>
      <td>1</td>
      <td>l2_a</td>
      <td>False</td>
      <td>1</td>
      <td>Default serie</td>
    </tr>
  </tbody>
</table>
</div><p>We can visualize (and modify making use of an interactive backend) the
stratigraphic pile. Since the formations are arbitary we can set them
by:</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="c1"># Original pile</span>
<span class="n">gp</span><span class="o">.</span><span class="n">get_sequential_pile</span><span class="p">(</span><span class="n">geo_data</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">gempy</span><span class="o">.</span><span class="n">sequential_pile</span><span class="o">.</span><span class="n">StratigraphicPile</span> <span class="n">at</span> <span class="mh">0x7fda8cfcb160</span><span class="o">&gt;</span>
</pre></div>
</div>
<img alt="../_images/ch3_10_1.png" src="../_images/ch3_10_1.png" />
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="c1"># Ordered pile</span>
<span class="n">gp</span><span class="o">.</span><span class="n">set_order_formations</span><span class="p">(</span><span class="n">geo_data</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Layer 2&#39;</span><span class="p">,</span> <span class="s1">&#39;Layer 3&#39;</span><span class="p">,</span> <span class="s1">&#39;Layer 4&#39;</span><span class="p">,</span><span class="s1">&#39;Layer 5&#39;</span><span class="p">])</span>
<span class="n">gp</span><span class="o">.</span><span class="n">get_sequential_pile</span><span class="p">(</span><span class="n">geo_data</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">gempy</span><span class="o">.</span><span class="n">sequential_pile</span><span class="o">.</span><span class="n">StratigraphicPile</span> <span class="n">at</span> <span class="mh">0x7fd9fe0bdac8</span><span class="o">&gt;</span>
</pre></div>
</div>
<img alt="../_images/ch3_11_1.png" src="../_images/ch3_11_1.png" />
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="c1"># and at all of the foliation data</span>
<span class="n">gp</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">geo_data</span><span class="p">,</span> <span class="s1">&#39;orientations&#39;</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>X</th>
      <th>Y</th>
      <th>Z</th>
      <th>G_x</th>
      <th>G_y</th>
      <th>G_z</th>
      <th>dip</th>
      <th>azimuth</th>
      <th>polarity</th>
      <th>formation</th>
      <th>series</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>500</td>
      <td>100</td>
      <td>1148</td>
      <td>-0.516992</td>
      <td>-0.00855937</td>
      <td>0.855947</td>
      <td>31.1355</td>
      <td>269.051</td>
      <td>1</td>
      <td>Layer 2</td>
      <td>Default serie</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2500</td>
      <td>100</td>
      <td>1147.33</td>
      <td>0.516122</td>
      <td>-0.0142732</td>
      <td>0.856397</td>
      <td>31.0857</td>
      <td>91.5841</td>
      <td>1</td>
      <td>Layer 2</td>
      <td>Default serie</td>
    </tr>
  </tbody>
</table>
</div></div>
<div class="section" id="visualize-the-input-data">
<h2>Visualize the input data<a class="headerlink" href="#visualize-the-input-data" title="Permalink to this headline">¶</a></h2>
<p>Now let’s have a look at the data in the xz-plane:</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">gp</span><span class="o">.</span><span class="n">plot_data</span><span class="p">(</span><span class="n">geo_data</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3000</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2000</span><span class="p">);</span>
</pre></div>
</div>
<img alt="../_images/ch3_14_0.png" src="../_images/ch3_14_0.png" />
<p>At this point we should store the input data object as a pickle, for
future reference:</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">gp</span><span class="o">.</span><span class="n">data_to_pickle</span><span class="p">(</span><span class="n">geo_data</span><span class="p">,</span> <span class="s2">&quot;./pickles/ch3-pymc2_tutorial_geo_data&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="compile-the-interpolator-function">
<h2>Compile the interpolator function<a class="headerlink" href="#compile-the-interpolator-function" title="Permalink to this headline">¶</a></h2>
<p>Now that we have some input data, the next step is to compile the
interpolator function of GemPy with the imported model setup and data:</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">interp_data</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">InterpolatorData</span><span class="p">(</span><span class="n">geo_data</span><span class="p">,</span> <span class="n">u_grade</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">compile_theano</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>Compiling theano function...
Compilation Done!
Level of Optimization:  fast_compile
Device:  cpu
Precision:  float32
Number of faults:  0
</pre></div>
</div>
<p>Afterwards we can compute the geological model:</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">lith_block</span><span class="p">,</span> <span class="n">fault_block</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">compute_model</span><span class="p">(</span><span class="n">interp_data</span><span class="p">)</span>
</pre></div>
</div>
<p>And plot a section:</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">gp</span><span class="o">.</span><span class="n">plot_section</span><span class="p">(</span><span class="n">geo_data</span><span class="p">,</span> <span class="n">lith_block</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">plot_data</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<img alt="../_images/ch3_22_0.png" src="../_images/ch3_22_0.png" />
</div>
<div class="section" id="setting-up-the-pymc-functions">
<h2>Setting up the pymc-Functions<a class="headerlink" href="#setting-up-the-pymc-functions" title="Permalink to this headline">¶</a></h2>
<p>pymc has two distinct types of objects: <strong>deterministic</strong> and
<strong>stochastic</strong> objects. As the <a class="reference external" href="https://pymc-devs.github.io/pymc/modelbuilding.html">pymc
documentation</a>
puts it: “A <em>Stochastic</em> object represents a variable whose value is not
completely determined by its parents, and a <em>Deterministic</em> object
represents a variable that is entirely determined by its parents.”
Stochastic objects can essentially be seen as <em>parameter distributions</em>
or <em>likelihood functions</em>, while Deterministic objects can be seen as
function that take a specific input and return a specific (determined)
output for this input. An example for the latter would be the modeling
function of GemPy, which takes a specific set of input parameters and
always creates the same model from those parameters.</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pymc</span>
</pre></div>
</div>
</div>
<div class="section" id="setting-up-the-parameter-distributions">
<h2>Setting up the parameter distributions<a class="headerlink" href="#setting-up-the-parameter-distributions" title="Permalink to this headline">¶</a></h2>
<p>For conducting a stochastic simulation of the geological model, we need
to consider our input data (dips and layer interfaces) as uncertain -
i.e. as distributions.</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="c1"># Checkpoint in case you did not execute the cells above</span>
<span class="n">geo_data</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">(</span><span class="s2">&quot;./pickles/ch3-pymc2_tutorial_geo_data.pickle&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">gp</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">geo_data</span><span class="p">,</span> <span class="s1">&#39;orientations&#39;</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>G_x</th>
      <th>G_y</th>
      <th>G_z</th>
      <th>X</th>
      <th>X_std</th>
      <th>Y</th>
      <th>Y_std</th>
      <th>Z</th>
      <th>Z_std</th>
      <th>annotations</th>
      <th>...</th>
      <th>azimuth_std</th>
      <th>dip</th>
      <th>dip_std</th>
      <th>formation</th>
      <th>formation_number</th>
      <th>group_id</th>
      <th>isFault</th>
      <th>order_series</th>
      <th>polarity</th>
      <th>series</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>-0.516992</td>
      <td>-0.00855937</td>
      <td>0.855947</td>
      <td>500</td>
      <td>NaN</td>
      <td>100</td>
      <td>NaN</td>
      <td>1148</td>
      <td>NaN</td>
      <td>${\bf{x}}_{\beta \,{\bf{1}},0}$</td>
      <td>...</td>
      <td>NaN</td>
      <td>31.1355</td>
      <td>NaN</td>
      <td>Layer 2</td>
      <td>1</td>
      <td>l2_a</td>
      <td>False</td>
      <td>1</td>
      <td>1</td>
      <td>Default serie</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.516122</td>
      <td>-0.0142732</td>
      <td>0.856397</td>
      <td>2500</td>
      <td>NaN</td>
      <td>100</td>
      <td>NaN</td>
      <td>1147.33</td>
      <td>NaN</td>
      <td>${\bf{x}}_{\beta \,{\bf{1}},1}$</td>
      <td>...</td>
      <td>NaN</td>
      <td>31.0857</td>
      <td>NaN</td>
      <td>Layer 2</td>
      <td>1</td>
      <td>l2_b</td>
      <td>False</td>
      <td>1</td>
      <td>1</td>
      <td>Default serie</td>
    </tr>
  </tbody>
</table>
<p>2 rows × 21 columns</p>
</div><p>So let’s assume the vertical location of our layer interfaces is
uncertain, and we want to represent this uncertainty by using a normal
distribution. To define a normal distribution, we need a mean and a
measure of deviation (e.g. standard deviation). For convenience the
input data is already grouped by a “group_id” value, which allows us to
collectively modify data that belongs together. In this example we want
to treat the vertical position of each layer interface, on each side of
the anticline, as uncertain. Therefore, we want to perturbate the
respective three points on each side of the anticline collectively.</p>
<p>These are our unique group id’s, the number representing the layer, and
a/b the side of the anticline.</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">group_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">geo_data</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s2">&quot;group_id&quot;</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">group_ids</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;l2_a&#39;</span> <span class="s1">&#39;l2_b&#39;</span> <span class="s1">&#39;l3_a&#39;</span> <span class="s1">&#39;l3_b&#39;</span> <span class="s1">&#39;l4_a&#39;</span> <span class="s1">&#39;l4_b&#39;</span> <span class="s1">&#39;l5_a&#39;</span> <span class="s1">&#39;l5_b&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>As a reminder, GemPy stores data in two main objects, an InputData
object (called geo_data in the tutorials) and a InpterpolatorInput
object (interp_data) in tutorials. geo_data contains the original data
while interp_data the data prepared (and compiled) to compute the 3D
model.</p>
<p>Since we do not want to compile our code at every new stochastic
realization, from here on we will need to work with thte interp_data.
And remember that to improve float32 to stability we need to work with
rescaled data (between 0 and 1). Therefore all the stochastic data needs
to be rescaled accordingly. The object interp_data contains a property
with the rescale factor (see below. As default depends on the model
extent), or it is possible to add the stochastic data to the pandas
dataframe of the geo_data—when the InterpolatorInput object is
created the rescaling happens under the hood.</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">interface_Z_modifier</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># We rescale the standard deviation</span>
<span class="n">std</span> <span class="o">=</span> <span class="mf">20.</span><span class="o">/</span><span class="n">interp_data</span><span class="o">.</span><span class="n">rescaling_factor</span>

<span class="c1"># loop over the unique group id&#39;s and create a pymc.Normal distribution for each</span>
<span class="k">for</span> <span class="n">gID</span> <span class="ow">in</span> <span class="n">group_ids</span><span class="p">:</span>
    <span class="n">stoch</span> <span class="o">=</span> <span class="n">pymc</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="n">gID</span><span class="o">+</span><span class="s1">&#39;_stoch&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="n">std</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">interface_Z_modifier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stoch</span><span class="p">)</span>
</pre></div>
</div>
<p>our list of parameter distribution:</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">interface_Z_modifier</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">&lt;</span><span class="n">pymc</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="n">new_dist_class</span><span class="o">.&lt;</span><span class="nb">locals</span><span class="o">&gt;.</span><span class="n">new_class</span> <span class="s1">&#39;l2_a_stoch&#39;</span> <span class="n">at</span> <span class="mh">0x7fd9e04e31d0</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="o">&lt;</span><span class="n">pymc</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="n">new_dist_class</span><span class="o">.&lt;</span><span class="nb">locals</span><span class="o">&gt;.</span><span class="n">new_class</span> <span class="s1">&#39;l2_b_stoch&#39;</span> <span class="n">at</span> <span class="mh">0x7fd9fd2e9240</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="o">&lt;</span><span class="n">pymc</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="n">new_dist_class</span><span class="o">.&lt;</span><span class="nb">locals</span><span class="o">&gt;.</span><span class="n">new_class</span> <span class="s1">&#39;l3_a_stoch&#39;</span> <span class="n">at</span> <span class="mh">0x7fd9fdfdff28</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="o">&lt;</span><span class="n">pymc</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="n">new_dist_class</span><span class="o">.&lt;</span><span class="nb">locals</span><span class="o">&gt;.</span><span class="n">new_class</span> <span class="s1">&#39;l3_b_stoch&#39;</span> <span class="n">at</span> <span class="mh">0x7fd9e04e3208</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="o">&lt;</span><span class="n">pymc</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="n">new_dist_class</span><span class="o">.&lt;</span><span class="nb">locals</span><span class="o">&gt;.</span><span class="n">new_class</span> <span class="s1">&#39;l4_a_stoch&#39;</span> <span class="n">at</span> <span class="mh">0x7fd9e04e36a0</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="o">&lt;</span><span class="n">pymc</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="n">new_dist_class</span><span class="o">.&lt;</span><span class="nb">locals</span><span class="o">&gt;.</span><span class="n">new_class</span> <span class="s1">&#39;l4_b_stoch&#39;</span> <span class="n">at</span> <span class="mh">0x7fd9e04e3978</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="o">&lt;</span><span class="n">pymc</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="n">new_dist_class</span><span class="o">.&lt;</span><span class="nb">locals</span><span class="o">&gt;.</span><span class="n">new_class</span> <span class="s1">&#39;l5_a_stoch&#39;</span> <span class="n">at</span> <span class="mh">0x7fd9e04e3748</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="o">&lt;</span><span class="n">pymc</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="n">new_dist_class</span><span class="o">.&lt;</span><span class="nb">locals</span><span class="o">&gt;.</span><span class="n">new_class</span> <span class="s1">&#39;l5_b_stoch&#39;</span> <span class="n">at</span> <span class="mh">0x7fd9e04e37b8</span><span class="o">&gt;</span><span class="p">]</span>
</pre></div>
</div>
<p>Let’s have a look at one:</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="c1"># sample from a distribtion</span>
<span class="n">samples</span> <span class="o">=</span> <span class="p">[</span><span class="n">interface_Z_modifier</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">)]</span>
<span class="c1"># plot histogram</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Z modifier&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">);</span>
</pre></div>
</div>
<img alt="../_images/ch3_36_0.png" src="../_images/ch3_36_0.png" />
<p>Now we need to somehow sample from these distribution and put them into
GemPy</p>
</div>
<div class="section" id="input-data-handling">
<h2>Input data handling<a class="headerlink" href="#input-data-handling" title="Permalink to this headline">¶</a></h2>
<p>First we need to write a function which modifies the input data for each
iteration of the stochastic simulation. As this process is highly
dependant on the simulation (e.g. what input parameters you want
modified in which way), this process generally can’t be automated.</p>
<p>The idea is to change the column Z (in this case) of the rescaled
dataframes in our interp_data object (which can be found in
interp_data.geo_data_res). First we simply create the pandas
Dataframes we are interested on:</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">copy</span>
<span class="c1"># First we extract from our original intep_data object the numerical data that is necessary for the interpolation.</span>
<span class="c1"># geo_data_stoch is a pandas Dataframe</span>

<span class="c1"># This is the inital model so it has to be outside the stochastic frame</span>
<span class="n">geo_data_stoch_init</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">interp_data</span><span class="o">.</span><span class="n">geo_data_res</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">gp</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">geo_data_stoch_init</span><span class="p">,</span> <span class="n">numeric</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>X</th>
      <th>Y</th>
      <th>Z</th>
      <th>G_x</th>
      <th>G_y</th>
      <th>G_z</th>
      <th>dip</th>
      <th>azimuth</th>
      <th>polarity</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">interfaces</th>
      <th>0</th>
      <td>0.2501</td>
      <td>0.4801</td>
      <td>0.5299</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.7001</td>
      <td>0.5201</td>
      <td>0.5605</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.6501</td>
      <td>0.5001</td>
      <td>0.5903</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.7501</td>
      <td>0.4801</td>
      <td>0.5297</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.3001</td>
      <td>0.5201</td>
      <td>0.5605</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div><div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="nd">@pymc.deterministic</span><span class="p">(</span><span class="n">trace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">input_data</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
               <span class="n">interface_Z_modifier</span> <span class="o">=</span> <span class="n">interface_Z_modifier</span><span class="p">,</span>
               <span class="n">geo_data_stoch_init</span> <span class="o">=</span> <span class="n">geo_data_stoch_init</span><span class="p">,</span>
               <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="c1"># First we extract from our original intep_data object the numerical data that is necessary for the interpolation.</span>
    <span class="c1"># geo_data_stoch is a pandas Dataframe</span>
 <span class="c1">#   geo_data_stoch = gp.get_data(interp_data_original.geo_data_res, numeric=True)</span>

    <span class="n">geo_data_stoch</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">geo_data_stoch_init</span><span class="p">,</span> <span class="n">numeric</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="c1"># Now we loop each id which share the same uncertainty variable. In this case, each layer.</span>
    <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">gID</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">group_ids</span><span class="p">):</span>
        <span class="c1"># First we obtain a boolean array with trues where the id coincide</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">interp_data</span><span class="o">.</span><span class="n">geo_data_res</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">)[</span><span class="s1">&#39;group_id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">gID</span>

        <span class="c1"># We add to the original Z value (its mean) the stochastic bit in the correspondant groups id</span>
        <span class="n">geo_data_stoch</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sel</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">]</span>  <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">interface_Z_modifier</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">geo_data_stoch</span><span class="p">)</span>

    <span class="c1"># then return the input data to be input into the modeling function. Due to the way pymc2 stores the traces</span>
    <span class="c1"># We need to save the data as numpy arrays</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">geo_data_stoch</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="s1">&#39;interfaces&#39;</span><span class="p">)[[</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">geo_data_stoch</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="s1">&#39;orientations&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="modeling-function">
<h2>Modeling function<a class="headerlink" href="#modeling-function" title="Permalink to this headline">¶</a></h2>
<p>Second, we need a function that takes the modified input data output by
the above function, and created our geological model from it. Although,
we could store the model itself it tends to be a too large file once we
make thousands of iterations. For this reason is preferible to keep the
input data and the geological model split and only to store the input
data ( which we will use to reconstruct each geological model since that
operation is deterministic).</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="nd">@pymc.deterministic</span><span class="p">(</span><span class="n">trace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">gempy_model</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">input_data</span><span class="o">=</span><span class="n">input_data</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>

    <span class="c1"># modify input data values accordingly</span>
    <span class="n">interp_data</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[[</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">input_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Gx, Gy, Gz are just used for visualization. The theano function gets azimuth dip and polarity!!!</span>
    <span class="n">interp_data</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">orientations</span><span class="p">[[</span><span class="s2">&quot;G_x&quot;</span><span class="p">,</span> <span class="s2">&quot;G_y&quot;</span><span class="p">,</span> <span class="s2">&quot;G_z&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">,</span>  <span class="s1">&#39;dip&#39;</span><span class="p">,</span> <span class="s1">&#39;azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;polarity&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">input_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># try to compute model</span>
        <span class="n">lb</span><span class="p">,</span> <span class="n">fb</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">compute_model</span><span class="p">(</span><span class="n">interp_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">gp</span><span class="o">.</span><span class="n">plot_section</span><span class="p">(</span><span class="n">interp_data</span><span class="o">.</span><span class="n">geo_data_res</span><span class="p">,</span> <span class="n">lb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">plot_data</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
           <span class="c1"># gp.plot_data(interp_data.geo_data_res, direction=&#39;y&#39;)</span>

        <span class="k">return</span> <span class="n">lb</span><span class="p">,</span> <span class="n">fb</span>

    <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="c1"># if it fails (e.g. some input data combinations could lead to</span>
        <span class="c1"># a singular matrix and thus break the chain) return an empty model</span>
        <span class="c1"># with same dimensions (just zeros)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Exception occured.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">lith_block</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">fault_block</span><span class="p">)</span>
</pre></div>
</div>
<img alt="../_images/ch3_43_0.png" src="../_images/ch3_43_0.png" />
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">interp_data</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">orientations</span>
</pre></div>
</div>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>G_x</th>
      <th>G_y</th>
      <th>G_z</th>
      <th>X</th>
      <th>X_std</th>
      <th>Y</th>
      <th>Y_std</th>
      <th>Z</th>
      <th>Z_std</th>
      <th>annotations</th>
      <th>...</th>
      <th>azimuth_std</th>
      <th>dip</th>
      <th>dip_std</th>
      <th>formation</th>
      <th>formation_number</th>
      <th>group_id</th>
      <th>isFault</th>
      <th>order_series</th>
      <th>polarity</th>
      <th>series</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.3001</td>
      <td>0.5001</td>
      <td>0.555743</td>
      <td>-0.516992</td>
      <td>NaN</td>
      <td>-0.008559</td>
      <td>NaN</td>
      <td>0.855947</td>
      <td>NaN</td>
      <td>${\bf{x}}_{\beta \,{\bf{1}},0}$</td>
      <td>...</td>
      <td>NaN</td>
      <td>31.135451</td>
      <td>NaN</td>
      <td>Layer 2</td>
      <td>1</td>
      <td>l2_a</td>
      <td>False</td>
      <td>1</td>
      <td>1.0</td>
      <td>Default serie</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.7001</td>
      <td>0.5001</td>
      <td>0.559481</td>
      <td>0.516122</td>
      <td>NaN</td>
      <td>-0.014273</td>
      <td>NaN</td>
      <td>0.856397</td>
      <td>NaN</td>
      <td>${\bf{x}}_{\beta \,{\bf{1}},1}$</td>
      <td>...</td>
      <td>NaN</td>
      <td>31.085652</td>
      <td>NaN</td>
      <td>Layer 2</td>
      <td>1</td>
      <td>l2_b</td>
      <td>False</td>
      <td>1</td>
      <td>1.0</td>
      <td>Default serie</td>
    </tr>
  </tbody>
</table>
<p>2 rows × 21 columns</p>
</div><p>We then create a pymc model with the two deterministic functions
(<em>input_data</em> and <em>gempy_model</em>), as well as all the prior parameter
distributions stored in the list <em>interface_Z_modifier</em>:</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_data</span><span class="p">,</span> <span class="n">gempy_model</span><span class="p">,</span> <span class="o">*</span><span class="n">interface_Z_modifier</span><span class="p">]</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">pymc</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we set the number of iterations:</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">iterations</span> <span class="o">=</span> <span class="mi">100</span>
</pre></div>
</div>
<p>Then we create an MCMC chain (in pymc an MCMC chain without a likelihood
function is essentially a Monte Carlo forward simulation) and specify an
hdf5 database to store the results in:</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">RUN</span> <span class="o">=</span> <span class="n">pymc</span><span class="o">.</span><span class="n">MCMC</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">db</span><span class="o">=</span><span class="s2">&quot;hdf5&quot;</span><span class="p">,</span> <span class="n">dbname</span><span class="o">=</span><span class="s2">&quot;./pymc-db/ch3-pymc2_tutorial-db&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>and we are finally able to run the simulation:</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">RUN</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">iter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">-----------------</span><span class="mi">100</span><span class="o">%-----------------</span><span class="p">]</span> <span class="mi">100</span> <span class="n">of</span> <span class="mi">100</span> <span class="n">complete</span> <span class="ow">in</span> <span class="mf">6.3</span> <span class="n">sec</span>
</pre></div>
</div>
</div>
<div class="section" id="analyzing-the-results">
<h2>Analyzing the results<a class="headerlink" href="#analyzing-the-results" title="Permalink to this headline">¶</a></h2>
<p>When we want to analyze the results, we first have to load the stored
geo_data object:</p>
<p>(this part is only necessary if the notebook above is not executed)</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">geo_data</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">(</span><span class="s2">&quot;./pymc-db/ch3-pymc2_tutorial_geo_data.pickle&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Check the stratigraphic pile for correctness:</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">gp</span><span class="o">.</span><span class="n">get_sequential_pile</span><span class="p">(</span><span class="n">geo_data</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">gempy</span><span class="o">.</span><span class="n">sequential_pile</span><span class="o">.</span><span class="n">StratigraphicPile</span> <span class="n">at</span> <span class="mh">0x7fd9e04e3a90</span><span class="o">&gt;</span>
</pre></div>
</div>
<img alt="../_images/ch3_56_1.png" src="../_images/ch3_56_1.png" />
<p>Then we can then compile the GemPy modeling function:</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">interp_data</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">InterpolatorData</span><span class="p">(</span><span class="n">geo_data</span><span class="p">,</span> <span class="n">u_grade</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>Now we can reproduce the original model:</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">lith_block</span><span class="p">,</span> <span class="n">fault_block</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">compute_model</span><span class="p">(</span><span class="n">interp_data</span><span class="p">)</span>
<span class="n">gp</span><span class="o">.</span><span class="n">plot_section</span><span class="p">(</span><span class="n">geo_data</span><span class="p">,</span> <span class="n">lith_block</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>Compiling theano function...
Compilation Done!
Level of Optimization:  fast_compile
Device:  cpu
Precision:  float32
Number of faults:  0
</pre></div>
</div>
<img alt="../_images/ch3_60_1.png" src="../_images/ch3_60_1.png" />
<p>But of course we want to look at the perturbation results. We have a
class for that:</p>
<p>(in the mid term the most important methods of this class will be moved
to the gempy main framework—i.e. gp)</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gempy.posterior_analysis</span>
<span class="kn">import</span> <span class="nn">importlib</span>
<span class="n">importlib</span><span class="o">.</span><span class="n">reload</span><span class="p">(</span><span class="n">gempy</span><span class="o">.</span><span class="n">posterior_analysis</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">module</span> <span class="s1">&#39;gempy.posterior_analysis&#39;</span> <span class="kn">from</span> <span class="s1">&#39;../../gempy/posterior_analysis.py&#39;</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Which allows us to load the stored pymc2 database</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">dbname</span> <span class="o">=</span> <span class="s2">&quot;ch3-pymc2_tutorial-db&quot;</span>
<span class="n">post</span> <span class="o">=</span> <span class="n">gempy</span><span class="o">.</span><span class="n">posterior_analysis</span><span class="o">.</span><span class="n">Posterior</span><span class="p">(</span><span class="n">dbname</span><span class="p">)</span>
</pre></div>
</div>
<p>Alright, it tells us that we did not tally any GemPy models (we set the
trace flag for the gempy_model function to False!). But we can just
replace the input data with the ones stored at each iteration. So let’s
plot the model result of the 85th iteration:</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">post</span><span class="o">.</span><span class="n">change_input_data</span><span class="p">(</span><span class="n">interp_data</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">gempy</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">InterpolatorData</span> <span class="n">at</span> <span class="mh">0x7fd9dff67c50</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Then we compute the model and plot it:</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">lith_block</span><span class="p">,</span> <span class="n">fault_block</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">compute_model</span><span class="p">(</span><span class="n">interp_data</span><span class="p">)</span>
<span class="n">gp</span><span class="o">.</span><span class="n">plot_section</span><span class="p">(</span><span class="n">interp_data</span><span class="o">.</span><span class="n">geo_data_res</span><span class="p">,</span> <span class="n">lith_block</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">plot_data</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<img alt="../_images/ch3_68_0.png" src="../_images/ch3_68_0.png" />
<p>or the 34th:</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">post</span><span class="o">.</span><span class="n">change_input_data</span><span class="p">(</span><span class="n">interp_data</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="n">lith_block</span><span class="p">,</span> <span class="n">fault_block</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">compute_model</span><span class="p">(</span><span class="n">interp_data</span><span class="p">)</span>
<span class="n">gp</span><span class="o">.</span><span class="n">plot_section</span><span class="p">(</span><span class="n">interp_data</span><span class="o">.</span><span class="n">geo_data_res</span><span class="p">,</span> <span class="n">lith_block</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">plot_data</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<img alt="../_images/ch3_70_0.png" src="../_images/ch3_70_0.png" />
<p>or the 95th:</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">post</span><span class="o">.</span><span class="n">change_input_data</span><span class="p">(</span><span class="n">interp_data</span><span class="p">,</span> <span class="mi">95</span><span class="p">)</span>
<span class="n">lith_block</span><span class="p">,</span> <span class="n">fault_block</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">compute_model</span><span class="p">(</span><span class="n">interp_data</span><span class="p">)</span>
<span class="n">gp</span><span class="o">.</span><span class="n">plot_section</span><span class="p">(</span><span class="n">geo_data</span><span class="p">,</span> <span class="n">lith_block</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<img alt="../_images/ch3_72_0.png" src="../_images/ch3_72_0.png" />
<p>As you can see, we have successfully perturbated the vertical layer
interface positions - although only like a 100 times. While some models
represent reasonable, geologically meaningful systems, some may not.
This is due to the stochastic selection of input parameters and an
inherent problem of the approach of Monte Carlo forward simulation -
results do not get validated in any sense. This where Bayesian inference
comes into play, as a method to constrain modeling outcomes by the use
of geological likelihood functions. We will introduce you to the
approach and how to use it with GemPy and pymc in the following chapter.</p>
<div class="highlight-ipython3"><div class="highlight"><pre><span></span><span class="n">ver</span><span class="p">,</span> <span class="n">sim</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">get_surfaces</span><span class="p">(</span><span class="n">interp_data</span><span class="p">,</span><span class="n">lith_block</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">None</span><span class="p">,</span> <span class="n">original_scale</span><span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
<span class="n">gp</span><span class="o">.</span><span class="n">plot_surfaces_3D_real_time</span><span class="p">(</span><span class="n">interp_data</span><span class="p">,</span> <span class="n">ver</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">posterior</span><span class="o">=</span><span class="n">post</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2018, Miguel de la Varga, CGR-Aachen Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/_notebooks/ch3.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>